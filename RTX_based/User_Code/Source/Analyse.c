
#include "Include.h"

/******************************************************************************
函数名：u32 Read_DS3231_Time(void)
返回值：4字节时间 秒钟
*******************************************************************************/
u32 Read_DS3231_Time(void)
{
	u32 Time_second = 0;
	u16 t;
	    //平年的月份表
	const u8 mon_table[12]={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30,31};
		

	u8 Read_Time_Data[7] = {0};



		//os_mut_wait(I2c_Mut_lm,0xFFFF);  //此处千万不能加锁，死了就明白了
		I2C_Read_DS3231(Read_Time_Data);			
		//os_mut_release(I2c_Mut_lm);			
		

	  for(t = 70;t < Read_Time_Data[6]+100;t++) //把所有年份的秒钟相加
	  {
	    if(Is_Leap_Year(1900 + t))
	    {
	      Time_second+=31622400;//闰年的秒钟数
	    }
	    else 
	    {
	      Time_second+=31536000; //平年的秒钟数
	    }
	  }
	  Read_Time_Data[5] -= 1;//月
	  for(t = 0;t < Read_Time_Data[5];t++) //把前面月份的秒钟数相加
	  {
	    Time_second += (u32)mon_table[t] * 86400;//月份秒钟数相加
	    if(Is_Leap_Year(Read_Time_Data[6] + 2000) && (t == 1))
	    {
	      Time_second += 86400;//闰年2月份增加一天的秒钟数
	    }
	  }
	  Time_second += (u32)((Read_Time_Data[4]-1) * 86400);//把前面日期的秒钟数相加
	  Time_second += (u32) (Read_Time_Data[2] * 3600);//小时秒钟数
	  Time_second += (u32) (Read_Time_Data[1] * 60); //分钟秒钟数
	  Time_second += Read_Time_Data[0];  //最后的秒钟加上去

	  return Time_second;
}

/******************************************************************************
函数名：uint8_t Is_Leap_Year(uint16_t year)
参数：uint16_t year
返回值：1,表示是闰年。 0，表示是平年
说明：判断是否为闰年
闰年：能被4整除但不能被100整除的为闰年， 能被400整除的为闰年
*******************************************************************************/
u8 Is_Leap_Year(u16 year)
{
  if((year % 4) == 0)  //如果能被4整除
  {
    if((year % 100) == 0) //如果能被100整除
    {
      if((year % 400) == 0)  //如果能被400整除
      {
        return 1;  //说明是闰年
      }
      else
      {
        return 0; //说明是平年
      }
    }
    else
    {
      return 1; ////说明是闰年
    }
  }
  else
  {
    return 0; //说明是平年
  }
}

//月份数据表,用于公历日期转换星期
const u8 table_week[12]={1, 4, 4, 0, 2, 5, 0, 3, 6, 1, 4, 6}; //月修正数据表
//平年的月份表
const u8 mon_table[12]={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30,31};


/*******************************************************************************
注：因为从公元1582年10月15日(星期五)才开始使用现行公历(格里高利历法)，
计算公元1583年及其以后某年的某月某日是星期几，先把年份前两位数a除以4求余数，
把余数乘以-2后，加上5，所得的和称之为“世纪余数”；
再把年份末两位数b除以4求其商的整数部分，然后加上年份末两位数b，
所得的和除以7之后所得余数称之为“年届余数”；再把每个月对应的一个数字，
这个数字称之为“月余数”，除闰年1月份和2月份所对应的数字分别是0和3之外，
平时1至12月份所对应的数字分别是1，4，4。0，2，5。0，3，6。1，4，6；
最后把所求这一日的“日期数”加上月份对应的“月余数”
再加上“世纪余数”和“年届余数”，求得这四个数字的和，再除以7，所得余数是几，
这一天便是星期几，余数为0时则是星期日。
*******************************************************************************/
u8 RTC_Get_Week(u16 year, u8 month, u8 day)
{
  u8 yearH, yearL;
  u8 temp1, temp2, temp3; 
  yearH = year / 100; 
  yearL = year % 100;
  temp1 = (yearH % 4) * 2 + 5;  //世纪余数
  temp2 = ((yearL / 4) + yearL) % 7;  //年届余数
  temp3 = temp1 + temp2 + day + table_week[month-1];
  if(((yearL % 4) == 0) && (month < 3))
    temp3--;
  return((u8)(temp3 % 7));
}


